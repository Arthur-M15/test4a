import threading
import multiprocessing
import time
import queue
from pygame import Surface
from common.biomes.properties.biome_generator_helper import get_height_index

from Settings import *

class MapManager(threading.Thread):
    def __init__(self, app_handler):
        super().__init__()
        self.app_handler = app_handler
        self.manager = multiprocessing.Manager()
        #self.external_command_list = self.manager.list()
        self.instruction_list = queue.Queue()
        self.__command_set = [self.manager.list() for _ in range(CHUNK_THREAD_NUMBER)]
        self.__result_set = [self.manager.list() for _ in range(CHUNK_THREAD_NUMBER)]
        self.error_logs_list = self.manager.list()
        self.process_list = [ChunkGenerator(i, self.__command_set[i], self.__result_set[i], self.error_logs_list) for i in range(CHUNK_THREAD_NUMBER)]

        # for test only:
        self.counter = 0
        self.__test()


    def check_new_commands(self):
        while True:
            try:
                instruction = self.instruction_list.get_nowait()
            except queue.Empty:
                break






        while len(self.external_command_list) > 0:
            command = self.external_command_list.pop(0)
            coordinates, command_type = command
            self.__add_command(coordinates, command_type)

    def __add_command(self, coordinates, command_type):
        try:
            modulo = (coordinates[0] + coordinates[1]) % CHUNK_THREAD_NUMBER

            if not self.app_handler.map.get(coordinates):
                self.app_handler.map.load_chunk(coordinates)

            copied_object = self.app_handler.map.get(coordinates).export()
            command = copied_object, command_type
            self.__command_set[modulo].append(command)
        except Exception as e:
            print(e)

    def collect(self):
        need_pause = True
        for result_list in self.__result_set:
            while len(result_list) > 0:
                result = result_list.pop(0)
                r_coordinates = result.get("coordinates")
                r_type = result.get("type")
                r_image = result.get("image")
                r_tiles= result.get("tiles")
                r_rect = result.get("rect")

                self.app_handler.map.get(r_coordinates).unload_from_screen()
                if r_type == "generate":
                    self.app_handler.map.paint_chunk(r_coordinates, r_image, r_tiles, r_rect)
                    self.app_handler.map.get(r_coordinates).load_on_screen()
                need_pause = False
        if need_pause:
            time.sleep(0.01)

    def run(self):
        if self.process_list:
            for process in self.process_list:
                process.start()

        while True:
            self.check_new_commands()
            self.collect()
            self.counter += 1
            time.sleep(0.01)

    def __test(self):
        self.__add_command((0, 0), "generate")
        self.__add_command((0, 1), "generate")
        self.__add_command((0, 0), "unload")
        time.sleep(2)
        print(self.error_logs_list)



class ChunkGenerator(multiprocessing.Process):
    def __init__(self, number, command_list, result_list, error_logs_list):
        super().__init__()
        self.number = number
        self.command_list = command_list
        self.result_list = result_list
        self.error_logs_list = error_logs_list
        self.running = False

    def run(self):
        self.running = True
        while self.running:
            self.execute_task()

    def execute_task(self):
        try:
            if self.command_list:
                while len(self.command_list) > 0:
                    command = self.command_list.pop(0)
                    if command[1] == "generate":
                        command[0].__generate_matrix()
                    result = {
                        "image": command[0].image,
                        "tiles": command[0].tiles,
                        "rect": command[0].rect,
                        "coordinates": command[0].coordinates,
                        "type": command[1]
                    }
                    self.result_list.append(result)
            else:
                time.sleep(0.01)

        except:
            error = sys.exc_info()
            log = (self.number, error)
            self.error_logs_list.append(log)


def generate_chunk_image(top_signal, bottom_signal, left_signal, right_signal, dominance_matrix, assets, coordinates):
    x_matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]
    y_matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]
    matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]
    size = CHUNK_SIZE * TILE_SIZE + TILE_SIZE / 4
    surf = Surface((size, size), pg.SRCALPHA)

    for i in range(CHUNK_SIZE):
        for j in range(CHUNK_SIZE):
            x_matrix[i][j] = \
                (top_signal[i] - ((j / CHUNK_SIZE) * (top_signal[i] - bottom_signal[i])))
            y_matrix[i][j] = \
                (left_signal[j] - ((i / CHUNK_SIZE) * (left_signal[j] - right_signal[j])))
            height = (x_matrix[i][j] + y_matrix[i][j]) / 2
            height_index = get_height_index(height, VARIANTS_NUMBER, TILE_HEIGHT_SATURATION)
            variant = dominance_matrix[i][j]
            chosen_image = assets[variant][height_index]
            surf.blit(chosen_image, (i * TILE_SIZE, j * TILE_SIZE))
            matrix[i][j] = (x_matrix[i][j] + y_matrix[j][i]) / 2
    if coordinates == (0, 0):
        corner = pg.image.load("corner.png")
        surf.blit(corner, (0, 0))

    return surf, matrix


def get_process_index(coordinates):
    return (coordinates[0] + coordinates[1]) % CHUNK_THREAD_NUMBER
