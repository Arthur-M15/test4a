import multiprocessing
import threading
import time

from Settings import *
from collections import deque
from PIL import Image as PILImage
from common.biomes.properties.biome_generator_helper import get_height_index, pil_to_sdl2


class MapManager:
    def __init__(self, parent_map):
        super().__init__()
        self.__map = parent_map
        self.__app_handler = parent_map.app_handler

        self.__command_counter = 0
        self.__command_list = {}

        assets = self.__map.biome_manager.tiles_assets
        frontier_biome = self.__map.biome_manager.dominance_matrix_index
        self.__process_manager = ProcessManager(assets, frontier_biome)

    def load(self, coordinates):
        self.__process_chunk(coordinates, "generate")

    def unload(self, coordinates):
        self.__process_chunk(coordinates, "unload")

    def update(self):
        wrap_list = self.__process_manager.get_results()
        for wrap in wrap_list:
            c_id = wrap.c_id
            command = self.__command_list.pop(c_id)
            command.wrap = wrap
            if command.task == "generate":
                command.merge_wrap()
                command.chunk.load_on_screen()
            else:
                command.chunk.unload_from_screen()

    """def __collect_results(self):
        
        return processed_list"""

    def __process_chunk(self, coordinates, task):
        chunk = self.__map.get_chunk(coordinates)
        command_id = self.__get_id()
        command = Command(chunk, task, command_id)
        wrap = command.wrap
        self.__command_list[command_id] = command
        self.__process_manager.add(wrap)

    def __get_id(self):
        if len(self.__command_list) == 0:
            self.__command_counter = 0
        return self.__command_counter

    def __get_assets(self):
        return self.__app_handler.biome_manager.tiles_assets

    def __get_dominance_matrix(self):
        return self.__app_handler.biome_manager.dominance_matrix_index


class ProcessManager(threading.Thread):
    def __init__(self, assets, frontier_biome_list):
        super().__init__()
        self.wrap_list = SharedList()
        self.result_list = SharedList()
        self.process_list = [Process(i, assets, frontier_biome_list, self.result_list, multiprocessing.Value(False)) for i in range(CHUNK_THREAD_NUMBER)]
        #self.process_list = {i: ProcessUnit(Process(i, assets, frontier_biome_list, self.result_list)) for i in range(CHUNK_THREAD_NUMBER)}
        self.daemon = True
        self.is_running = False
        self.start()

    def run(self):
        #[unit.process.start() for unit in self.process_list.values()]
        [process.start() for process in self.process_list]
        time.sleep(CHUNK_THREAD_NUMBER*0.5)
        self.is_running = True
        while self.is_running:
            self.__send_to_process()

    def add(self, wrap):
        self.wrap_list.add_item(wrap)

    def get_results(self):
        return self.result_list.flush()

    def __get_process_id(self):
        for process in self.process_list:
            if not process.is_loaded:
                return process.id
        return -1

    def __send_to_process(self):
        while len(self.wrap_list) > 0:
            command_id = self.__get_process_id()
            if command_id != -1:
                wrap = self.wrap_list.pop_item()
                self.process_list[command_id].notify_process(wrap)
                pass
                #self.process_list.get(command_id).process.notify_process(wrap)
            else:
                time.sleep(0.1)


class Process(multiprocessing.Process):
    def __init__(self, p_id, assets, frontier_biome_list, result_list, is_loaded):
        super().__init__()
        self.id = p_id
        self.assets = assets
        self.frontier_biome_list = frontier_biome_list

        self.result_list = result_list
        self.is_running = False

        self.wrap = None
        self.is_loaded = is_loaded
        self.command_id = 0
        self.lock = multiprocessing.Lock()

    def run2(self):
        while self.is_running:
            pass


    def run(self):
        self.is_running = True
        while self.is_running:
            t = time.time()
            if self.is_loaded:
                print("bbbbbbbbbb")
            with self.lock:
                if self.is_loaded:
                    print('yeeeeees !')
                    self.__execute_task()
                    self.is_loaded = False
            delta = time.time() - t
            if 0.020 - delta > 0.0:
                time.sleep(0.020 - delta)

    def notify_process(self, wrap):
        with self.lock:
            self.wrap = wrap
            self.is_loaded = True
            print("cccccc")

    def __execute_task(self):
        try:
            wrap = self.wrap
            print("aaaaaa")
            if wrap.task == "generate":
                result = self.__generate_image(wrap.signals, wrap.frontier_biome, wrap.biome_name)
                wrap.pil_image = result[0]
                wrap.tiles = result[1]
            self.result_list.add_item(wrap)
        except Exception as e:
            print(e)
        finally:
            self.wrap = None


    def __generate_image(self, signals, frontier_biome, biome_name):
        return
        x_matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]
        y_matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]
        matrix = [[0] * CHUNK_SIZE for _ in range(CHUNK_SIZE)]

        size = int(CHUNK_SIZE * TILE_SIZE + TILE_SIZE / 4)
        canvas = PILImage.new("RGBA", (size, size), (0, 0, 0, 0))

        dominance_matrix = self.frontier_biome_list[frontier_biome]

        top_s = signals.get("top_signal")
        bottom_s = signals.get("bottom_signal")
        left_s = signals.get("left_signal")
        right_s = signals.get("right_signal")

        for i in range(CHUNK_SIZE):
            for j in range(CHUNK_SIZE):
                x_matrix[i][j] = top_s[i] - ((j / CHUNK_SIZE) * (top_s[i]) - bottom_s[i])
                y_matrix[i][j] = left_s[j] - ((i / CHUNK_SIZE) * (left_s[j]) - right_s[j])
                matrix[i][j] = (x_matrix[i][j] + y_matrix[j][i]) / 2 # noqa

                variant = dominance_matrix[i][j]
                height_index = get_height_index(matrix[i][j], VARIANTS_NUMBER, TILE_HEIGHT_SATURATION)
                pil_image = self.assets.get(biome_name)[variant][height_index]
                canvas.paste(pil_image, (i * TILE_SIZE, j * TILE_SIZE), mask=pil_image)

        return canvas, matrix


class SharedList:
    def __init__(self):
        self.lock = multiprocessing.Lock()
        self.shared_list = deque()

    def add_item(self, item):
        with self.lock:
            self.shared_list.append(item)

    def pop_item(self):
        with self.lock:
            print("pop")
            return self.shared_list.popleft()

    def flush(self):
        result_list = []
        with self.lock:
            while len(self.shared_list) > 0:
                result_list.append(self.shared_list.popleft())
        return result_list

    def __len__(self):
        with self.lock:
            return len(self.shared_list)


class Command:
    def __init__(self, chunk, task, c_id):
        self.chunk = chunk
        self.task = task

        signals = self.chunk.get_information()
        frontier_biome = self.chunk.frontier_biome
        biome_name = self.chunk.biome.name
        self.wrap = Wrap(c_id, signals, task, frontier_biome, biome_name)

    def merge_wrap(self):
        if self.wrap.pil_image is not None and self.wrap.tiles is not None:
            renderer = self.chunk.app_handler.app.renderer
            sdl_image = pil_to_sdl2(renderer, self.wrap.pil_image)
            rect = sdl_image.get_rect()
            tiles = self.wrap.tiles
            self.chunk.tiles = tiles
            self.chunk.image = sdl_image
            self.chunk.rect = rect
        else:
            raise Exception("no image to merge")


class Wrap:
    def __init__(self, c_id, signals, task, frontier_biome, biome_name):
        self.c_id = c_id
        self.signals = signals
        self.task = task
        self.frontier_biome = frontier_biome
        self.biome_name = biome_name

        self.pil_image = None
        self.tiles = None
        self.timestamp = time.time()

